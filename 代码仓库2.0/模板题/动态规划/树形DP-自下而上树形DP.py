"""
1319 蓝桥舞会
https://www.lanqiao.cn/problems/1319/learning
"""
'''
也就是孙子可以和爷爷一起参加，当不可以个亲爹一起参加
一个儿子只有一个爹，但可以有多个儿子,因此采用邻接表来存储一个点的所有儿子
每个节点都有一个权值，求整棵树上最大的权值


对于除了叶子结点的每个点：
当一个点选了，它的直接儿子不能选，反之亦然
当这个点没选，则它的儿子可以选当然也可以不选，具体选不选，应比较选与不选哪种所获得的权值最大

因此，状态有两个维度：每个节点，该节点选与不选。(第二维中0表示不选这个节点，1表示选这个节点)
dp数组中存的应该是以这个点为根的整颗子树的累计最大权值
因此应该从叶子节点开始向上更新状态，直到根节点就是最终解
最终问题：max(dp[0][0],dp[0][1])表示根节点选与不选所获得的整棵树的最大权值
子问题：
dp[i][0]  表示第i个节点不选，其子树的累计最大权值
dp[i][1]  表示第i个节点选，其子树的累计最大权值

状态转移方程：
dp[i][0] = max(dp[j][0],dp[j][1])   只有当i点不选时，其子节点才可以选，也可以不选，由权值最大的决策转移过来
dp[i][1] = dp[j][0]       若i点选了，则其子节点只能不选，由子节点不选时的权值转移过来

首先需要先找到叶子结点，因此我们需要从根节点出发自上而下做dfs，
到达叶子结点后，再自下而上利用dp逐层递归更新状态，而根节点就是最终状态

因此我们需要
1.建图：构建一个邻接表存储每个节点所指向的点，用于找到他的子节点，
当一个点没有子节点时，它就是叶子结点  （子上而下寻找根节点时使用）
2.构建dp状态矩阵，用于记录新状态   （自底向上更新状态时使用）
3.因为根节点的编号不一定为0，比如样例中就是1，所以还要构建一个标记数组，
  标记所有有爹的节点，从而找到根节点
'''
from collections import defaultdict
edg = defaultdict(list)

n = int(input())#n个点
#权重值
happy =[0] + [*map(int,input().split())]
#初始化状态矩阵
#n个节点，每个节点由长度为2的列表存储：0号位存储不选该点能获得的最大权值（因为不选，所以初始值为0)
                                    # 1号位表示选，所以初始值为该点的权值
dp = [[0,happy[i]]for i in range(n+1)]
fa = [0] * (n+1)

#构建邻接表（图）
#有n个节点的树，最多有n-1条边
for i in range(n-1):
  u,v = map(int,input().split())
  edg[v].append(u)    #爹为键，儿子为值
  fa[u] = 1           #标记有爹的节点

def dfs(v):
  #递归向下找叶子结点
  for u in edg[v]:    #遍历该点的所有子节点,若该点是叶子结点，则不会进入该循环，直接返回他的父节点
    dfs(u)            #搜寻子节点的子节点

       #若找到叶子结点，则返回他的父节点（开始自底向上更新状态）

    #自底向上累计更新状态  （因为一个爹可能有多个儿子，所以该段需方在循环里）
    dp[v][1] += dp[u][0]
    dp[v][0] += max(dp[u][0],dp[u][1]) 
    
#寻找根节点
root = 0   #初始化根节点序号为0
for i in range(1,n+1):
    if not fa[i] :   #若根节点不是0
        root = i

dfs(root)   #自上而下搜索
ans = max(dp[root][0],dp[root][1])
print(ans)
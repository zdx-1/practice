"""
3711 选数异或
https://www.lanqiao.cn/problems/3711/learning

着重解释dp[i][j] = (dp[i-1][j] + dp[i-1][j^a[i]]) % mod这句代码的意思。
这句代码的目的是求i个正整数异或得到j的子序列数量并对mod取模，
而问题就在于为什么i个正整数异或得到j的子序列数量就等于(dp[i-1][j]+dp[i-1][j^a[i]])?
dp[i-1][j]指的是i-1个正整数异或得到j的子序列数量，并不包含a[i]，这很好理解。

我们需要考虑的是a[i]加入后的影响，
即dp[i-1][j^a[i]]，
它表示i-1个正整数异或得到j^a[i]的子序列数量（也就是子集数量）。
有人或许会疑问：
这怎么考虑加入a[i]后的影响了?别急，
现在才加入a[i]。我们加入a[i]后，
这句代码计算的便是j^a[i]^a[i]的子序列数量，
而a[i]^a[i]一定等于0，j^0一定等于j，
也就是j^a[i]^a[i]一定等于j，
即这句代码计算的是j的子序列数量。
我们得到了一个等价关系：
不包含a[i]的i-1个正整数异或得到j^a[i]的子序列数量
等价于包含a[i]后新增的满足条件的子序列数量。

现在我们解决了等式右边两个部分的含义，
我们是时候解决这个等式为什么成立了。
这是因为，对于数组中的每一个元素，
我们都有两种选择：包含它或者不包含它。
i个正整数如果不能包含a[i]时，
即dp[i-1][j^a[i]＝0，
则i个正整数满足条件的子序列数量就相当于i-1个正整数满足条件的子序列数量，
就等于dp[i-1][j]；如果能包含a[i]，
则i个正整数满足条件的子序列数量
就等于不包含a[i]的i-1个正整数满足条件的子序列数量
加上因为包含a[i]新增的满足条件的子序列数量。

动态规划的核心思想应该就是这样：
当前状态=前一个状态+引入当前状态后的改变量，
这个改变量可增可减，但一定能由前一状态得到。
这就像数学归纳法一样：
证明初始状态成立，再假设前一状态成立，
如果能利用前一状态证明出当前状态成立，
则命题成立。
动态规划也类似：
找到初始状态，
再通过前一个状态找出引入当前状态后的改变量，
则问题解决。
其实单看这个改变量感觉也挺像递推公式。
"""
n,x=map(int,input().split())
a=[0]+list(map(int,input().split()))
dp=[[0]*64 for _ in range(n+1)]
dp[0][0]=1
for i in range(1,n+1):
    for j in range(64):
        dp[i][j]=(dp[i-1][j]+dp[i-1][j^a[i]])%998244353
print(dp[n][x])